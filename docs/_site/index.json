{
  "api/AzureServiceBusFlow.Abstractions.ICommandProducer-1.html": {
    "href": "api/AzureServiceBusFlow.Abstractions.ICommandProducer-1.html",
    "title": "Interface ICommandProducer<TCommand> | AzureServiceBusFlow",
    "summary": "Interface ICommandProducer<TCommand> Namespace AzureServiceBusFlow.Abstractions Assembly AzureServiceBusFlow.Configurations.dll public interface ICommandProducer<in TCommand> where TCommand : class, IServiceBusMessage Type Parameters TCommand Methods ProduceCommandAsync(TCommand, MessageOptions, CancellationToken) Task ProduceCommandAsync(TCommand command, MessageOptions messageOptions, CancellationToken cancellationToken) Parameters command TCommand messageOptions MessageOptions cancellationToken CancellationToken Returns Task ProduceCommandAsync(TCommand, CancellationToken) Task ProduceCommandAsync(TCommand command, CancellationToken cancellationToken) Parameters command TCommand cancellationToken CancellationToken Returns Task"
  },
  "api/AzureServiceBusFlow.Abstractions.IEventProducer-1.html": {
    "href": "api/AzureServiceBusFlow.Abstractions.IEventProducer-1.html",
    "title": "Interface IEventProducer<TEvent> | AzureServiceBusFlow",
    "summary": "Interface IEventProducer<TEvent> Namespace AzureServiceBusFlow.Abstractions Assembly AzureServiceBusFlow.Configurations.dll public interface IEventProducer<in TEvent> where TEvent : class, IServiceBusMessage Type Parameters TEvent Methods ProduceEventAsync(TEvent, CancellationToken) Task ProduceEventAsync(TEvent @event, CancellationToken cancellationToken) Parameters event TEvent cancellationToken CancellationToken Returns Task"
  },
  "api/AzureServiceBusFlow.Abstractions.IMessageHandler-1.html": {
    "href": "api/AzureServiceBusFlow.Abstractions.IMessageHandler-1.html",
    "title": "Interface IMessageHandler<T> | AzureServiceBusFlow",
    "summary": "Interface IMessageHandler<T> Namespace AzureServiceBusFlow.Abstractions Assembly AzureServiceBusFlow.Configurations.dll public interface IMessageHandler<in T> Type Parameters T Methods HandleAsync(T, ServiceBusReceivedMessage, CancellationToken) Task HandleAsync(T message, ServiceBusReceivedMessage rawMessage, CancellationToken cancellationToken) Parameters message T rawMessage ServiceBusReceivedMessage cancellationToken CancellationToken Returns Task"
  },
  "api/AzureServiceBusFlow.Abstractions.IServiceBusMessage.html": {
    "href": "api/AzureServiceBusFlow.Abstractions.IServiceBusMessage.html",
    "title": "Interface IServiceBusMessage | AzureServiceBusFlow",
    "summary": "Interface IServiceBusMessage Namespace AzureServiceBusFlow.Abstractions Assembly AzureServiceBusFlow.Configurations.dll public interface IServiceBusMessage Properties CreatedDate DateTime CreatedDate { get; } Property Value DateTime RoutingKey string RoutingKey { get; } Property Value string"
  },
  "api/AzureServiceBusFlow.Abstractions.IServiceBusProducer-1.html": {
    "href": "api/AzureServiceBusFlow.Abstractions.IServiceBusProducer-1.html",
    "title": "Interface IServiceBusProducer<TMessage> | AzureServiceBusFlow",
    "summary": "Interface IServiceBusProducer<TMessage> Namespace AzureServiceBusFlow.Abstractions Assembly AzureServiceBusFlow.Configurations.dll public interface IServiceBusProducer<in TMessage> where TMessage : class, IServiceBusMessage Type Parameters TMessage Methods ProduceAsync(TMessage, MessageOptions, CancellationToken) Task ProduceAsync(TMessage message, MessageOptions producerOptions, CancellationToken cancellationToken) Parameters message TMessage producerOptions MessageOptions cancellationToken CancellationToken Returns Task ProduceAsync(TMessage, CancellationToken) Task ProduceAsync(TMessage message, CancellationToken cancellationToken) Parameters message TMessage cancellationToken CancellationToken Returns Task"
  },
  "api/AzureServiceBusFlow.Abstractions.html": {
    "href": "api/AzureServiceBusFlow.Abstractions.html",
    "title": "Namespace AzureServiceBusFlow.Abstractions | AzureServiceBusFlow",
    "summary": "Namespace AzureServiceBusFlow.Abstractions Interfaces ICommandProducer<TCommand> IEventProducer<TEvent> IMessageHandler<T> IServiceBusMessage IServiceBusProducer<TMessage>"
  },
  "api/AzureServiceBusFlow.Builders.ServiceBusConfigurationBuilder.html": {
    "href": "api/AzureServiceBusFlow.Builders.ServiceBusConfigurationBuilder.html",
    "title": "Class ServiceBusConfigurationBuilder | AzureServiceBusFlow",
    "summary": "Class ServiceBusConfigurationBuilder Namespace AzureServiceBusFlow.Builders Assembly AzureServiceBusFlow.Configurations.dll Builder for configuring Azure Service Bus, allowing connection, producers, and consumers setup. public class ServiceBusConfigurationBuilder Inheritance object ServiceBusConfigurationBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceBusConfigurationBuilder(IServiceCollection) Builder for configuring Azure Service Bus, allowing connection, producers, and consumers setup. public ServiceBusConfigurationBuilder(IServiceCollection services) Parameters services IServiceCollection Properties AzureServiceBusConfiguration The connection string used to connect to Azure Service Bus. public AzureServiceBusConfiguration AzureServiceBusConfiguration { get; } Property Value AzureServiceBusConfiguration Methods AddConsumer(Action<ServiceBusConsumerConfigurationBuilder>) Adds a consumer configuration via a callback. public ServiceBusConfigurationBuilder AddConsumer(Action<ServiceBusConsumerConfigurationBuilder> configure) Parameters configure Action<ServiceBusConsumerConfigurationBuilder> Action to configure the consumer, receives a specific builder. Returns ServiceBusConfigurationBuilder Returns the builder itself for method chaining. AddProducer<TMessage>(Action<ServiceBusProducerConfigurationBuilder<TMessage>>) Adds a producer for messages of type TMessage configured via a callback. public ServiceBusConfigurationBuilder AddProducer<TMessage>(Action<ServiceBusProducerConfigurationBuilder<TMessage>> configure) where TMessage : class, IServiceBusMessage Parameters configure Action<ServiceBusProducerConfigurationBuilder<TMessage>> Action to configure the producer, receives a specific builder. Returns ServiceBusConfigurationBuilder Returns the builder itself for method chaining. Type Parameters TMessage The type of message to produce, must implement IServiceBusMessage. Build() Validates the configuration and ensures required properties are set. public void Build() Exceptions InvalidOperationException Thrown when the connection string is not set. ConfigureAzureServiceBus(AzureServiceBusConfiguration) Sets the connection string that will be used for all Service Bus operations. public ServiceBusConfigurationBuilder ConfigureAzureServiceBus(AzureServiceBusConfiguration azureServiceBusConfiguration) Parameters azureServiceBusConfiguration AzureServiceBusConfiguration Returns ServiceBusConfigurationBuilder Returns the builder itself for method chaining."
  },
  "api/AzureServiceBusFlow.Builders.ServiceBusConsumerConfigurationBuilder.html": {
    "href": "api/AzureServiceBusFlow.Builders.ServiceBusConsumerConfigurationBuilder.html",
    "title": "Class ServiceBusConsumerConfigurationBuilder | AzureServiceBusFlow",
    "summary": "Class ServiceBusConsumerConfigurationBuilder Namespace AzureServiceBusFlow.Builders Assembly AzureServiceBusFlow.Configurations.dll public class ServiceBusConsumerConfigurationBuilder Inheritance object ServiceBusConsumerConfigurationBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceBusConsumerConfigurationBuilder(AzureServiceBusConfiguration, IServiceCollection) public ServiceBusConsumerConfigurationBuilder(AzureServiceBusConfiguration _azureServiceBusConfiguration, IServiceCollection services) Parameters _azureServiceBusConfiguration AzureServiceBusConfiguration services IServiceCollection Methods AddHandler<TMessage, THandler>() public ServiceBusConsumerConfigurationBuilder AddHandler<TMessage, THandler>() where TMessage : class, IServiceBusMessage where THandler : class, IMessageHandler<TMessage> Returns ServiceBusConsumerConfigurationBuilder Type Parameters TMessage THandler Build() public void Build() EnsureSubscriptionExists(string, string) public ServiceBusConsumerConfigurationBuilder EnsureSubscriptionExists(string topicName, string subscriptionName) Parameters topicName string subscriptionName string Returns ServiceBusConsumerConfigurationBuilder FromQueue(string) public ServiceBusConsumerConfigurationBuilder FromQueue(string queueName) Parameters queueName string Returns ServiceBusConsumerConfigurationBuilder FromTopic(string, string) public ServiceBusConsumerConfigurationBuilder FromTopic(string topicName, string subscriptionName) Parameters topicName string subscriptionName string Returns ServiceBusConsumerConfigurationBuilder"
  },
  "api/AzureServiceBusFlow.Builders.ServiceBusProducerConfigurationBuilder-1.html": {
    "href": "api/AzureServiceBusFlow.Builders.ServiceBusProducerConfigurationBuilder-1.html",
    "title": "Class ServiceBusProducerConfigurationBuilder<TMessage> | AzureServiceBusFlow",
    "summary": "Class ServiceBusProducerConfigurationBuilder<TMessage> Namespace AzureServiceBusFlow.Builders Assembly AzureServiceBusFlow.Configurations.dll public class ServiceBusProducerConfigurationBuilder<TMessage> where TMessage : class, IServiceBusMessage Type Parameters TMessage Inheritance object ServiceBusProducerConfigurationBuilder<TMessage> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceBusProducerConfigurationBuilder(AzureServiceBusConfiguration, IServiceCollection) public ServiceBusProducerConfigurationBuilder(AzureServiceBusConfiguration azureServiceBusConfiguration, IServiceCollection services) Parameters azureServiceBusConfiguration AzureServiceBusConfiguration services IServiceCollection Methods EnsureQueueExists(string) public ServiceBusProducerConfigurationBuilder<TMessage> EnsureQueueExists(string queueName) Parameters queueName string Returns ServiceBusProducerConfigurationBuilder<TMessage> EnsureTopicExists(string) public ServiceBusProducerConfigurationBuilder<TMessage> EnsureTopicExists(string topicName) Parameters topicName string Returns ServiceBusProducerConfigurationBuilder<TMessage> ToQueue(string) public ServiceBusProducerConfigurationBuilder<TMessage> ToQueue(string queueName) Parameters queueName string Returns ServiceBusProducerConfigurationBuilder<TMessage> ToTopic(string) public ServiceBusProducerConfigurationBuilder<TMessage> ToTopic(string topicName) Parameters topicName string Returns ServiceBusProducerConfigurationBuilder<TMessage> WithCommandProducer() public ServiceBusProducerConfigurationBuilder<TMessage> WithCommandProducer() Returns ServiceBusProducerConfigurationBuilder<TMessage> WithEventProducer() public ServiceBusProducerConfigurationBuilder<TMessage> WithEventProducer() Returns ServiceBusProducerConfigurationBuilder<TMessage> WithQueue(string) public ServiceBusProducerConfigurationBuilder<TMessage> WithQueue(string queue) Parameters queue string Returns ServiceBusProducerConfigurationBuilder<TMessage> WithTopic(string) public ServiceBusProducerConfigurationBuilder<TMessage> WithTopic(string topic) Parameters topic string Returns ServiceBusProducerConfigurationBuilder<TMessage>"
  },
  "api/AzureServiceBusFlow.Builders.html": {
    "href": "api/AzureServiceBusFlow.Builders.html",
    "title": "Namespace AzureServiceBusFlow.Builders | AzureServiceBusFlow",
    "summary": "Namespace AzureServiceBusFlow.Builders Classes ServiceBusConfigurationBuilder Builder for configuring Azure Service Bus, allowing connection, producers, and consumers setup. ServiceBusConsumerConfigurationBuilder ServiceBusProducerConfigurationBuilder<TMessage>"
  },
  "api/AzureServiceBusFlow.Extensions.AzureServiceBusExtensions.html": {
    "href": "api/AzureServiceBusFlow.Extensions.AzureServiceBusExtensions.html",
    "title": "Class AzureServiceBusExtensions | AzureServiceBusFlow",
    "summary": "Class AzureServiceBusExtensions Namespace AzureServiceBusFlow.Extensions Assembly AzureServiceBusFlow.Configurations.dll public static class AzureServiceBusExtensions Inheritance object AzureServiceBusExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddAzureServiceBus(IServiceCollection, Action<ServiceBusConfigurationBuilder>) public static IServiceCollection AddAzureServiceBus(this IServiceCollection services, Action<ServiceBusConfigurationBuilder> configure) Parameters services IServiceCollection configure Action<ServiceBusConfigurationBuilder> Returns IServiceCollection"
  },
  "api/AzureServiceBusFlow.Extensions.html": {
    "href": "api/AzureServiceBusFlow.Extensions.html",
    "title": "Namespace AzureServiceBusFlow.Extensions | AzureServiceBusFlow",
    "summary": "Namespace AzureServiceBusFlow.Extensions Classes AzureServiceBusExtensions"
  },
  "api/AzureServiceBusFlow.Hosts.ServiceBusConsumerHostedService.html": {
    "href": "api/AzureServiceBusFlow.Hosts.ServiceBusConsumerHostedService.html",
    "title": "Class ServiceBusConsumerHostedService | AzureServiceBusFlow",
    "summary": "Class ServiceBusConsumerHostedService Namespace AzureServiceBusFlow.Hosts Assembly AzureServiceBusFlow.Configurations.dll public class ServiceBusConsumerHostedService : IHostedService, IAsyncDisposable Inheritance object ServiceBusConsumerHostedService Implements IHostedService IAsyncDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceBusConsumerHostedService(Func<ServiceBusReceivedMessage, IServiceProvider, CancellationToken, Task>, IServiceProvider, ILogger, AzureServiceBusConfiguration, string, string) public ServiceBusConsumerHostedService(Func<ServiceBusReceivedMessage, IServiceProvider, CancellationToken, Task> messageHandler, IServiceProvider serviceProvider, ILogger logger, AzureServiceBusConfiguration azureServiceBusConfiguration, string queueOrTopicName, string subscriptionName = null) Parameters messageHandler Func<ServiceBusReceivedMessage, IServiceProvider, CancellationToken, Task> serviceProvider IServiceProvider logger ILogger azureServiceBusConfiguration AzureServiceBusConfiguration queueOrTopicName string subscriptionName string Methods DisposeAsync() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources asynchronously. public ValueTask DisposeAsync() Returns ValueTask A task that represents the asynchronous dispose operation. StartAsync(CancellationToken) Triggered when the application host is ready to start the service. public Task StartAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Indicates that the start process has been aborted. Returns Task A Task that represents the asynchronous Start operation. StopAsync(CancellationToken) Triggered when the application host is performing a graceful shutdown. public Task StopAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Indicates that the shutdown process should no longer be graceful. Returns Task A Task that represents the asynchronous Stop operation."
  },
  "api/AzureServiceBusFlow.Hosts.html": {
    "href": "api/AzureServiceBusFlow.Hosts.html",
    "title": "Namespace AzureServiceBusFlow.Hosts | AzureServiceBusFlow",
    "summary": "Namespace AzureServiceBusFlow.Hosts Classes ServiceBusConsumerHostedService"
  },
  "api/AzureServiceBusFlow.Models.AzureServiceBusConfiguration.html": {
    "href": "api/AzureServiceBusFlow.Models.AzureServiceBusConfiguration.html",
    "title": "Class AzureServiceBusConfiguration | AzureServiceBusFlow",
    "summary": "Class AzureServiceBusConfiguration Namespace AzureServiceBusFlow.Models Assembly AzureServiceBusFlow.Configurations.dll public class AzureServiceBusConfiguration Inheritance object AzureServiceBusConfiguration Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ConnectionString public required string ConnectionString { get; set; } Property Value string MaxAutoLockRenewalDurationInSeconds public int MaxAutoLockRenewalDurationInSeconds { get; set; } Property Value int MaxConcurrentCalls public int MaxConcurrentCalls { get; set; } Property Value int MaxRetryAttempts public int MaxRetryAttempts { get; set; } Property Value int ServiceBusReceiveMode public required ServiceBusReceiveMode ServiceBusReceiveMode { get; set; } Property Value ServiceBusReceiveMode"
  },
  "api/AzureServiceBusFlow.Models.MessageOptions.html": {
    "href": "api/AzureServiceBusFlow.Models.MessageOptions.html",
    "title": "Class MessageOptions | AzureServiceBusFlow",
    "summary": "Class MessageOptions Namespace AzureServiceBusFlow.Models Assembly AzureServiceBusFlow.Configurations.dll public record MessageOptions : IEquatable<MessageOptions> Inheritance object MessageOptions Implements IEquatable<MessageOptions> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MessageOptions(TimeSpan?, IDictionary<string, object>?) public MessageOptions(TimeSpan? Delay, IDictionary<string, object>? ApplicationProperties) Parameters Delay TimeSpan? ApplicationProperties IDictionary<string, object> Properties ApplicationProperties public IDictionary<string, object>? ApplicationProperties { get; init; } Property Value IDictionary<string, object> Delay public TimeSpan? Delay { get; init; } Property Value TimeSpan?"
  },
  "api/AzureServiceBusFlow.Models.html": {
    "href": "api/AzureServiceBusFlow.Models.html",
    "title": "Namespace AzureServiceBusFlow.Models | AzureServiceBusFlow",
    "summary": "Namespace AzureServiceBusFlow.Models Classes AzureServiceBusConfiguration MessageOptions"
  },
  "api/AzureServiceBusFlow.Producers.CommandProducer-1.html": {
    "href": "api/AzureServiceBusFlow.Producers.CommandProducer-1.html",
    "title": "Class CommandProducer<TCommand> | AzureServiceBusFlow",
    "summary": "Class CommandProducer<TCommand> Namespace AzureServiceBusFlow.Producers Assembly AzureServiceBusFlow.Configurations.dll public class CommandProducer<TCommand> : ICommandProducer<TCommand> where TCommand : class, IServiceBusMessage Type Parameters TCommand Inheritance object CommandProducer<TCommand> Implements ICommandProducer<TCommand> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CommandProducer(IServiceBusProducer<TCommand>) public CommandProducer(IServiceBusProducer<TCommand> producer) Parameters producer IServiceBusProducer<TCommand> Methods ProduceCommandAsync(TCommand, MessageOptions, CancellationToken) public Task ProduceCommandAsync(TCommand command, MessageOptions messageOptions, CancellationToken cancellationToken) Parameters command TCommand messageOptions MessageOptions cancellationToken CancellationToken Returns Task ProduceCommandAsync(TCommand, CancellationToken) public Task ProduceCommandAsync(TCommand command, CancellationToken cancellationToken) Parameters command TCommand cancellationToken CancellationToken Returns Task"
  },
  "api/AzureServiceBusFlow.Producers.EventProducer-1.html": {
    "href": "api/AzureServiceBusFlow.Producers.EventProducer-1.html",
    "title": "Class EventProducer<TEvent> | AzureServiceBusFlow",
    "summary": "Class EventProducer<TEvent> Namespace AzureServiceBusFlow.Producers Assembly AzureServiceBusFlow.Configurations.dll public class EventProducer<TEvent> : IEventProducer<TEvent> where TEvent : class, IServiceBusMessage Type Parameters TEvent Inheritance object EventProducer<TEvent> Implements IEventProducer<TEvent> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors EventProducer(IServiceBusProducer<TEvent>) public EventProducer(IServiceBusProducer<TEvent> producer) Parameters producer IServiceBusProducer<TEvent> Methods ProduceEventAsync(TEvent, CancellationToken) public Task ProduceEventAsync(TEvent @event, CancellationToken cancellationToken) Parameters event TEvent cancellationToken CancellationToken Returns Task"
  },
  "api/AzureServiceBusFlow.Producers.ServiceBusProducer-1.html": {
    "href": "api/AzureServiceBusFlow.Producers.ServiceBusProducer-1.html",
    "title": "Class ServiceBusProducer<TMessage> | AzureServiceBusFlow",
    "summary": "Class ServiceBusProducer<TMessage> Namespace AzureServiceBusFlow.Producers Assembly AzureServiceBusFlow.Configurations.dll public class ServiceBusProducer<TMessage> : IServiceBusProducer<TMessage> where TMessage : class, IServiceBusMessage Type Parameters TMessage Inheritance object ServiceBusProducer<TMessage> Implements IServiceBusProducer<TMessage> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ServiceBusProducer(AzureServiceBusConfiguration, string, ILogger) public ServiceBusProducer(AzureServiceBusConfiguration azureServiceBusConfiguration, string queueOrTopicName, ILogger logger) Parameters azureServiceBusConfiguration AzureServiceBusConfiguration queueOrTopicName string logger ILogger Methods ProduceAsync(TMessage, MessageOptions, CancellationToken) public Task ProduceAsync(TMessage message, MessageOptions producerOptions, CancellationToken cancellationToken) Parameters message TMessage producerOptions MessageOptions cancellationToken CancellationToken Returns Task ProduceAsync(TMessage, CancellationToken) public Task ProduceAsync(TMessage message, CancellationToken cancellationToken) Parameters message TMessage cancellationToken CancellationToken Returns Task"
  },
  "api/AzureServiceBusFlow.Producers.html": {
    "href": "api/AzureServiceBusFlow.Producers.html",
    "title": "Namespace AzureServiceBusFlow.Producers | AzureServiceBusFlow",
    "summary": "Namespace AzureServiceBusFlow.Producers Classes CommandProducer<TCommand> EventProducer<TEvent> ServiceBusProducer<TMessage>"
  },
  "docs/commandsAndEventsConcept.html": {
    "href": "docs/commandsAndEventsConcept.html",
    "title": "Commands and Events | AzureServiceBusFlow",
    "summary": "Commands and Events In AzureServiceBusFlow, messages are generally divided into two conceptual categories: Commands and Events. Although they are represented in code using the same message structures, their purpose and meaning differ from an architectural perspective. ✒️ Commands A command expresses the intention to perform an action. It usually represents a request from one part of the system asking another to execute a specific operation. Commands are imperative — they tell the system what should be done. Examples: CreateOrderCommand UpdateUserProfileCommand ProcessPaymentCommand A command typically has a single intended consumer, as it represents a direct request that must be handled once. flowchart LR A[CommandProducer] --> |CreateOrderCommand| B(AzureServiceBus) --> C[CreateOrder] \uD83D\uDD14 Events An event indicates that something has already happened. It is a notification sent to inform other parts of the system that a specific state change occurred. Events are descriptive — they tell the system what has happened. Examples: OrderCreatedEvent UserProfileUpdatedEvent PaymentProcessedEvent Unlike commands, events are often broadcast to multiple subscribers, allowing different services to react independently. flowchart LR A[EventProducer] --> |OrderCreatedEvent| B(AzureServiceBus) --> C[NotifyCustomer] B --> D[ProcessPayment] B --> E[ProcessOrder] \uD83E\uDDE9 Architectural Difference Command Event Meaning Intention to perform an action Notification that something occurred Temporal Aspect Future-oriented Past-oriented Consumer Count Usually one One or many Communication Type Point-to-point Publish-subscribe Example CreateOrderCommand OrderCreatedEvent \uD83D\uDCA1 Although they share the same implementation in code, their semantic purpose defines whether a message should be treated as a command or an event."
  },
  "docs/creatingConsumers.html": {
    "href": "docs/creatingConsumers.html",
    "title": "Consumers | AzureServiceBusFlow",
    "summary": "Consumers AzureServiceBusFlow also simplify the creation of Consumers or MessageHandlers by implementing the IMessageHandler<> interface and passing the Message that will be consumed as the Type of the Handler. This interface provides the HandleAsync() method that is used to process the received message. \uD83D\uDEE0️ Creating a Consumer public class CommandExample1Handler : IMessageHandler<ExampleCommand1> { public Task HandleAsync(ExampleCommand1 message, ServiceBusReceivedMessage rawMessage, CancellationToken cancellationToken) { return Task.CompletedTask; } } The MessageHandler above consume a Message of type ExampleCommand1, created earlier in this documentation (ExampleCommand1). ⚙️ Registering Consumer To register the Consumer, aka MessageHandler, we need to use the AddConsumer() extension method in AddAzureServiceBus() configuration methon in Program.cs. the AddConsummer() method requires a Action of type ServiceBusConsumerConfigurationBuilder to configure the Consumer using this methods: FromQueue(): Defines the Queue this Consumer will be receiving messages. FromTopic(): Defines the Topic this Consumer will be receiving messages. EnsureSubscriptionExists(): Ensure that the subscription passed exists in AzureServiceBus, creates it if doesn`t exists. AddHandler<TMessage, TMessageHandler>(): Defines the Consumer / MessageHandler that is goint to consume a specific Message from a Queue or a Topic. More than one Consumer to the same Message, Queue or Topic can be defined in the same AddConsumer() This example shows the full configuration for: Registering a Message Creating a Producer for it Publishing in a specifi Queue Configuring a Consumer / MessageHandler for the Message Consuming this Message from the same Queue. builder.Services.AddAzureServiceBus(cfg => cfg .ConfigureAzureServiceBus(azureServiceBusConfig) .AddProducer<ExampleCommand1>(p => p .EnsureQueueExists(\"command-queue-one\") .WithCommandProducer() .ToQueue(\"command-queue-one\")) .AddConsumer(c => c .FromQueue(\"command-queue-one\") .AddHandler<ExampleCommand1, CommandExemple1Handler>()) ); The complete flow of sending a message and consuming it with the MessageHandler we just created is shown below. flowchart LR A[__producer_] -->|ExampleCommand1| B B -->|ExampleCommand1| C[CommandExemple1Handler] subgraph AzureServiceBus B([command-queue-one]) end"
  },
  "docs/creatingMessages.html": {
    "href": "docs/creatingMessages.html",
    "title": "Messages | AzureServiceBusFlow",
    "summary": "Messages The AzureServiceBusFlow defines a standard approach for creating messages that will be published to the bus. This ensures that the MessageHandler receives the correct message type and processes it properly. ✉️ Creating Messages To create these messages, you need to define a record or class that implements IServiceBusMessage interface from the AzureServiceBusFlow package. public class ExampleCommand1 : IServiceBusMessage { public string RoutingKey => ExampleMessage.Id.ToString(); public DateTime CreatedDate => DateTime.UtcNow; public required ExampleMessage ExampleMessage { get; set; } } public class ExampleMessage { public Guid Id { get; set; } public string? Cliente { get; set; } public decimal Valor { get; set; } } The RoutingKey and CreatedDate properties are used internally by AzureServiceBusFlow, while ExampleMessage represents the actual content of the message being sent. The message above is just an example and the Content can be of any type, such as a class, record, struct, integer, string, IEnumerable... To register which messages will be sent to the bus, we need to configure the Producers to publish the messages. Check out the next page to know how to register it."
  },
  "docs/messageComponent.html": {
    "href": "docs/messageComponent.html",
    "title": "Messages | AzureServiceBusFlow",
    "summary": "Messages In AzureServiceBusFlow (AsbFlow), every message that is sent through the Azure Service Bus — whether it is a Command or an Event — must implement the IServiceBusMessage interface. This interface defines the basic structure that all messages must follow, ensuring consistency and allowing the framework to automatically handle serialization, metadata, and routing. \uD83E\uDDE9 IServiceBusMessage Interface public interface IServiceBusMessage { string RoutingKey { get; } DateTime CreatedDate { get; } } Every message must expose: RoutingKey → used to identify or categorize the message (often a unique ID or business key) CreatedDate → timestamp of when the message was created \uD83E\uDDF1 Example of a Command Message public class ExampleCommand1 : IServiceBusMessage { public string RoutingKey => ExampleMessage.Id.ToString(); public DateTime CreatedDate => DateTime.UtcNow; public required ExampleMessage ExampleMessage { get; set; } } public class ExampleMessage { public Guid Id { get; set; } public string? Cliente { get; set; } public decimal Valor { get; set; } } This structure provides: A strongly typed message model Easy serialization through the built-in producer A unified standard for both commands and events ⚙️ Architectural Meaning Although both commands and events share the same implementation, they differ in intention: A Command represents the intention to perform an action. An Event indicates that something has already happened. The distinction is purely architectural and helps maintain clear separation of responsibilities between services."
  },
  "docs/messageConcept.html": {
    "href": "docs/messageConcept.html",
    "title": "Messages and Azure Service Bus Overview | AzureServiceBusFlow",
    "summary": "Messages and Azure Service Bus Overview Azure Service Bus is a fully managed enterprise messaging system that enables reliable communication between distributed applications. It decouples application components, allowing them to exchange messages in a secure and asynchronous manner. In AzureServiceBusFlow (AsbFlow), a message represents the fundamental unit of communication between different parts of the system. Messages can be commands, events, or any other type of information that needs to be transmitted through queues or topics. \uD83D\uDCE6 What Is a Message? A message is a piece of data sent from one application or service to another. It can represent: A request to perform an operation A notification that something has occurred Data exchange between microservices \uD83D\uDD04 Message Flow A producer sends a message to a queue or topic. The Azure Service Bus stores and delivers the message reliably. A consumer receives the message and processes it. flowchart LR A[Producer] -->|Message| B(Azure Service Bus) B -->|Message| C[Consumer] This architecture ensures asynchronous, loosely coupled communication, improving scalability and resilience in distributed systems. \uD83D\uDE80 AsbFlow’s Role AzureServiceBusFlow simplifies the process of defining and managing these messages by: Providing a clean, strongly typed model for message definition Enforcing consistent configuration patterns for message producers and consumers Allowing automatic setup of queues, topics, and subscriptions"
  },
  "docs/messageHandlerComponent.html": {
    "href": "docs/messageHandlerComponent.html",
    "title": "⚙️ Message Handlers | AzureServiceBusFlow",
    "summary": "⚙️ Message Handlers A Message Handler defines how a message should be processed once it is received from Azure Service Bus. In AzureServiceBusFlow, every handler must implement the IMessageHandler<TMessage> interface, where TMessage is the type of message being handled. This ensures a clean and consistent processing model across all services. \uD83E\uDDE9 IMessageHandler Interface public interface IMessageHandler<in TMessage> { Task HandleAsync( TMessage message, ServiceBusReceivedMessage rawMessage, CancellationToken cancellationToken); } \uD83E\uDDF1 Example of a Command Handler public class CommandExample1Handler : IMessageHandler<ExampleCommand1> { public Task HandleAsync(ExampleCommand1 message, ServiceBusReceivedMessage rawMessage, CancellationToken cancellationToken) { // Business logic to handle the command Console.WriteLine($\"Processing command for client: {message.ExampleMessage.Cliente}\"); return Task.CompletedTask; } } In this example: The handler consumes an ExampleCommand1 message. It receives both the deserialized message and the raw Azure Service Bus message. The method HandleAsync is executed automatically when a message is consumed. \uD83E\uDDE0 Key Benefits Strong typing ensures compile-time safety. Clear separation between different message types and business logic. Automatic binding via dependency injection and the AsbFlow configuration. Handlers allow your application to stay modular, scalable, and easy to test."
  },
  "docs/producersAndConsumersConcept.html": {
    "href": "docs/producersAndConsumersConcept.html",
    "title": "Producers and Consumers | AzureServiceBusFlow",
    "summary": "Producers and Consumers In AzureServiceBusFlow, communication between services happens through producers and consumers, which abstract away the complexity of connecting to Azure Service Bus. \uD83D\uDE80 Producers A producer (also known as a sender) is responsible for sending messages to a queue or topic. With AsbFlow, producers are registered and configured fluently using simple definitions. They can send either commands or events, depending on the communication model. Example responsibilities: Serializing the message payload Sending the message to the appropriate Azure Service Bus entity Logging and error handling \uD83D\uDCE5 Consumers A consumer (or receiver) is responsible for receiving and processing messages from queues or subscriptions. In AsbFlow, consumers are also registered fluently and can automatically bind to queues or subscriptions, depending on message type. Example responsibilities: Deserializing the message Executing the related business logic Handling retries and exceptions \uD83E\uDDE9 Relationship Component Description Producer Sends messages to Azure Service Bus (queues or topics). Consumer Listens for and processes incoming messages. Queue/Topic The channel through which messages flow. This abstraction makes it easy to maintain a clean architecture, where producers and consumers are clearly separated and follow consistent configuration patterns."
  },
  "docs/producersComponent.html": {
    "href": "docs/producersComponent.html",
    "title": "Producers | AzureServiceBusFlow",
    "summary": "Producers Producers are responsible for sending messages to Azure Service Bus queues or topics. The AzureServiceBusFlow package provides built-in producer interfaces and implementations, allowing you to send both Commands and Events easily and consistently. \uD83E\uDDE9 Producer Interfaces The library defines two main producer interfaces: public interface ICommandProducer<in TCommand> where TCommand : class, IServiceBusMessage { Task ProduceCommandAsync(TCommand command, CancellationToken cancellationToken); } public interface IEventProducer<in TEvent> where TEvent : class, IServiceBusMessage { Task ProduceEventAsync(TEvent @event, CancellationToken cancellationToken); } These interfaces abstract the underlying logic of sending messages to the Azure Service Bus. ⚙️ Internal Implementation Both producers rely on a shared low-level component: the IServiceBusProducer interface. public interface IServiceBusProducer<in TMessage> where TMessage : class, IServiceBusMessage { Task ProduceAsync(TMessage message, CancellationToken cancellationToken); } The default implementation, ServiceBusProducer<TMessage>, uses the Azure SDK to serialize and send the message: public class ServiceBusProducer<TMessage> : IServiceBusProducer<TMessage> where TMessage : class, IServiceBusMessage { public async Task ProduceAsync(TMessage message, CancellationToken cancellationToken) { var json = JsonConvert.SerializeObject(message); var serviceBusMessage = new ServiceBusMessage(json) { Subject = message.RoutingKey, ApplicationProperties = { { \"MessageType\", message.GetType().FullName }, { \"CreatedAt\", message.CreatedDate.ToString(\"O\") } } }; await _sender.SendMessageAsync(serviceBusMessage, cancellationToken); _logger.LogInformation(\"Message {MessageType} published successfully!\", message.GetType().Name); } } \uD83E\uDDF1 Example of Usage in a Controller You don’t need to create a custom producer class — AsbFlow already provides the implementations. Simply inject the appropriate interface (ICommandProducer or IEventProducer) and call the Produce...Async method: [Route(\"api/commands\")] [ApiController] public class CommandController(ICommandProducer<ExampleCommand1> _producer) : ControllerBase { [HttpPost(\"command-example-one\")] public async Task<IActionResult> Example1(CancellationToken cancellationToken) { ExampleCommand1 command = new() { ExampleMessage = new ExampleMessage { Cliente = \"jose\", Id = Guid.NewGuid(), Valor = 1111 } }; await _producer.ProduceCommandAsync(command, cancellationToken); return Ok(\"Command published successfully!\"); } } \uD83E\uDDE0 Key Points Both CommandProducer and EventProducer share the same implementation logic. The difference lies only in architectural intent — commands indicate actions to be performed, events indicate actions that already happened. You can use dependency injection to directly obtain any producer type."
  },
  "docs/queuesAndTopicsConcept.html": {
    "href": "docs/queuesAndTopicsConcept.html",
    "title": "Queues and Topics | AzureServiceBusFlow",
    "summary": "Queues and Topics Azure Service Bus provides two main types of messaging entities — queues and topics — each suited for specific communication patterns. \uD83D\uDCE5 Queues A queue is a simple, point-to-point communication channel. Each message is received by only one consumer. Messages are stored until a consumer successfully processes them. Ideal for command processing or task-based workloads. Example use cases: Order processing Email sending jobs Background task execution flowchart LR A[Producer] --> |Message| B --> |Message| C[Consumer] subgraph AzureServiceBus B([Queue]) end \uD83D\uDCE2 Topics and Subscriptions A topic enables a publish-subscribe messaging pattern. Producers send messages to a topic. Multiple subscriptions can be attached to a topic. Each subscription receives a copy of the message. Ideal for event broadcasting or system-wide notifications. Example use cases: Notifying multiple microservices about an order creation Updating caches after a data change Triggering independent workflows after an event flowchart LR A[Producer/Publisher] --> |Message|B B --> |Message| C[Consumer1/Subscription1] B --> |Message| D[Consumer2/Subscription2] B --> |Message| E[Consumer3/Subscription3] subgraph AzureServiceBus B(Topic) end \uD83E\uDDE9 Summary Feature Queue Topic Pattern Point-to-point Publish-subscribe Consumers per message One Many (via subscriptions) Typical usage Commands Events Message copy Single One per subscription AsbFlow automatically configures queues, topics, and subscriptions for you, making setup and maintenance straightforward."
  },
  "docs/registeringProducers.html": {
    "href": "docs/registeringProducers.html",
    "title": "Producers | AzureServiceBusFlow",
    "summary": "Producers To simplify the process of sending messages to Azure Service Bus, we created an abstraction that encapsulates the publishing logic. This approach keeps the implementation consistent and allows any type of message to be sent using the same pattern. ⚙️ Registering a Producer Sending Messages to a Queue To register a producer and configure which message it will send, use the AddProducer() method inside the AddAzureServiceBus() configuration method in Program.cs: builder.Services.AddAzureServiceBus(cfg => cfg .ConfigureAzureServiceBus(azureServiceBusConfig) .AddProducer<ExampleCommand1>(p => p .EnsureQueueExists(\"command-queue-one\") .WithCommandProducer() .ToQueue(\"command-queue-one\"))); The code above registers a producer for the ExampleCommand1 Message created earlier in this documentation (ExampleCommand1). EnsureQueueExists(): Ensures that the specified Queue exists in Azure Service Bus. If the Queue does not exist, it will be created automatically. WithCommandProducer(): Specifies that the producer is of type CommandProducer. Alternatively, you can configure an EventProducer or a CommandProducer, depending on the message type. ToQueue(): Defines the Queue where the message will be published. Sending Messages to a Topic If you want the producer to publish messages to a Topic instead of a Queue, you can use the methods EnsureTopicExists() and ToTopic() in the same configuration pattern: builder.Services.AddAzureServiceBus(cfg => cfg .ConfigureAzureServiceBus(azureServiceBusConfig) .AddProducer<ExampleEvent1>(p => p .EnsureTopicExists(\"event-topic-one\") .WithEventProducer() .ToTopic(\"event-topic-one\"))); EnsureTopicExists(): Ensures that the specified Topic exists in Azure Service Bus. If the Topic does not exist, it will be automatically created. WithEventProducer(): Specifies that the producer is of type EventProducer. Alternatively, you can configure an CommandProducer or a EventProducer, depending on the message type. ToTopic(): Defines the Topic where the message will be published. \uD83D\uDCE4 Publishing Messages Once the producer is configured, it can be used to publish messages to the bus. Here’s an example of how to do it. To publish a message as a Command, inject an instance of ICommandProducer and call ProduceCommandAsync(), passing the message as a parameter. To publish a message as an Event, do the same using IEventProducer and call ProduceEventAsync(). [Route(\"api/commands\")] [ApiController] public class CommandController(ICommandProducer<ExampleCommand1> _producer) : ControllerBase { [HttpPost(\"command-example-one\")] public async Task<IActionResult> Example1(CancellationToken cancellationToken) { ExampleCommand1 command = new() { ExampleMessage = new ExampleMessage { Cliente = \"jose\", Id = Guid.NewGuid(), Valor = 1111 } }; await _producer.ProduceCommandAsync(command, cancellationToken); return Ok(); } } The flowchart below shows the flow of sending the message created in the previous example. flowchart LR A[__producer_] -->|ExampleCommand1| B B -->|ExampleCommand1| C[Consumer...] subgraph AzureServiceBus B([command-queue-one]) end \uD83E\uDDED Summary \uD83D\uDCAC Message created \uD83D\uDCE4 Producer configured \uD83D\uDCEC Queue or Topic created and registred Next step: Create MessageHandler to consume and process the message."
  },
  "docs/settingUp.html": {
    "href": "docs/settingUp.html",
    "title": "Configuring your API | AzureServiceBusFlow",
    "summary": "Configuring your API \uD83D\uDCE6 Step 1: Install the NuGet Package Start by installing the AzureServiceBusFlow package from NuGet: dotnet add package AzureServiceBusFlow You can also find it on NuGet.org. This package contains all the necessary components to configure Producers / Consumers, register Queues / Topics and publish Messages (Commands/ Events) to AzureServiceBus. ⚙️ Step 2: Configure the appsettings.json After installing the package, it's time to configure your appsettings.json file. You need to define the basic configuration for Azure Service Bus to work. Here’s a configuration example: \"AzureServiceBusConfigurationSettings\": { \"ConnectionString\": \"\", \"ServiceBusReceiveMode\": \"ReceiveAndDelete\", \"MaxAutoLockRenewalDurationInSeconds\": \"1800\", \"MaxConcurrentCalls\": \"10\", \"MaxRetryAttempts\": \"3\" } ConnectionString: The full connection string to your Azure Service Bus instance, typically in the format: Endpoint=sb://<your-servicebus-namespace-name>.servicebus.windows.net/;SharedAccessKeyName=<your-access-key-name>;SharedAccessKey=<your-access-key-value>. ServiceBusReceiveMode: Defines how messages are handled after being received. \"PeekLock\": The message is locked for processing and remains in the queue until it is explicitly completed or abandoned. If the receiver fails to complete the message within the lock duration, the message becomes available again for other receivers. \"ReceiveAndDelete\": The message is automatically removed from the queue as soon as it is received. MaxAutoLockRenewalDurationInSeconds: The maximum duration, in seconds, that the message lock will be automatically renewed while the message is being processed. MaxConcurrentCalls: Specifies the maximum number of messages that can be processed concurrently. MaxRetryAttempts: Defines the maximum number of retry attempts the message handler will perform to reprocess a message if an exception occurs. \uD83E\uDDE9 Step 3: Register AzureServiceBus in Program.cs Now that your appsettings.json is configured, it's time to enable AzureServiceBus in your application. Inside your Program.cs, register the AzureServiceBus in DI container with the AddAzureServiceBus extension method and set the configure method. var azureServiceBusConfig = new AzureServiceBusConfiguration { ConnectionString = \"\", ServiceBusReceiveMode = Azure.Messaging.ServiceBus.ServiceBusReceiveMode.ReceiveAndDelete, MaxConcurrentCalls = 10, MaxAutoLockRenewalDurationInSeconds = 1800, MaxRetryAttempts = 2 }; builder.Services.AddAzureServiceBus(cfg => cfg .ConfigureAzureServiceBus(azureServiceBusConfig)); This method need a AzureServiceBusConfiguration instance to configure all the necessary properties to work with the Azure Service Bus. At this time, no queues, topics, producers or consumers are configured and registered. This will be done in the next steps. \uD83D\uDCA1 I recommend you create a class called Settings and map the appsettings.json on this class, you can merge your personal appsettings config and also add the AzureServiceBusFlow properties that are required. For example: { \"Settings\": { \"AzureServiceBusConfigurationSettings\": { \"ConnectionString\": \"\", \"ServiceBusReceiveMode\": \"ReceiveAndDelete\", \"MaxAutoLockRenewalDurationInSeconds\": \"1800\", \"MaxConcurrentCalls\": \"10\", \"MaxRetryAttempts\": \"3\" } } } public class Settings { public AzureServiceBusConfiguration AzureServiceBusConfigurationSettings { get; } } var applicationSettings = builder.Configuration.GetSection(\"Settings\").Get<Settings>(); \uD83D\uDD12 Next Steps: Create Messages, Producers, Consumers, Queues and Topics. In the next step, we`ll explain how to create Messages and Producers that will publish to a specific queue or topic in Azure Service Bus."
  },
  "index.html": {
    "href": "index.html",
    "title": "AzureServiceBusFlow | AzureServiceBusFlow",
    "summary": "AzureServiceBusFlow AzureServiceBusFlow (or AsbFlow) is a lightweight and fluent integration library for Azure Service Bus, designed to simplify and standardize message-based communication in .NET applications. Inspired by the configuration style and modular design of KafkaFlow, AsbFlow provides a clean, extensible API that helps developers easily configure producers, consumers, topics, queues, and subscriptions — without repetitive boilerplate code. ✨ Features Fluent configuration for Azure Service Bus resources Automatic creation of topics, queues, and subscriptions Producer and consumer abstraction layers Built-in dependency injection support Structured logging with ILogger integration \uD83D\uDE4C Contributors Meet the amazing people behind AzureServiceBusFlow! Connect with them on LinkedIn: Name LinkedIn Profile Felipe Mattioli Richard Garcia Miguel Totti \uD83D\uDCA1 Want to Contribute? We welcome all contributions! If you have ideas, feedback, or want to help improve AzureServiceBusFlow, feel free to: Open an issue in the GitHub repository Submit a Pull Request Together we can make Azure Service Bus integration in .NET even more seamless and developer-friendly."
  }
}