<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Producers | AzureServiceBusFlow </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Producers | AzureServiceBusFlow ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/migueltotti/AzureServiceBusFlow/blob/main/docs/docs/producersComponent.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="AzureServiceBusFlow">
            AzureServiceBusFlow
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="producers"><strong>Producers</strong></h1>

<p><strong>Producers</strong> are responsible for <strong>sending messages</strong> to Azure Service Bus queues or topics.<br>
The <strong>AzureServiceBusFlow</strong> package provides built-in producer interfaces and implementations, allowing you to send both <strong>Commands</strong> and <strong>Events</strong> easily and consistently.</p>
<br>
<h2 id="-producer-interfaces">üß© Producer Interfaces</h2>
<p>The library defines two main producer interfaces:</p>
<pre><code class="lang-csharp">public interface ICommandProducer&lt;in TCommand&gt; where TCommand : class, IServiceBusMessage
{
    /// &lt;summary&gt;
    /// Produces the command without additional options.
    /// &lt;/summary&gt;
    Task ProduceCommandAsync(TCommand command, CancellationToken cancellationToken);

    /// &lt;summary&gt;
    /// Produces the command using explicit message options such as delay or application properties.
    /// &lt;/summary&gt;
    Task ProduceCommandAsync(TCommand command, MessageOptions messageOptions, CancellationToken cancellationToken);

    /// &lt;summary&gt;
    /// Produces the command with a set of application properties that will be attached to the message.
    /// &lt;/summary&gt;
    Task ProduceCommandAsync(TCommand command, IDictionary&lt;string, object&gt; applicationProperties, CancellationToken cancellationToken);

    /// &lt;summary&gt;
    /// Produces the command with a delivery delay before it becomes available for processing.
    /// &lt;/summary&gt;
    Task ProduceCommandAsync(TCommand command, TimeSpan delay, CancellationToken cancellationToken);
}

public interface IEventProducer&lt;in TEvent&gt; where TEvent : class, IServiceBusMessage
{
    Task ProduceEventAsync(TEvent @event, CancellationToken cancellationToken);
}
</code></pre>
<p>These interfaces abstract the underlying logic of sending messages to the Azure Service Bus.</p>
<p>The overload of <code>ProduceCommandAsync</code> by the <strong><code>ICommandProducer&lt;TCommand&gt;</code></strong> interface accepts a <strong><code>MessageOptions</code></strong> object, defined as:</p>
<pre><code class="lang-csharp">public record MessageOptions(TimeSpan? Delay, IDictionary&lt;string, object&gt;? ApplicationProperties);
</code></pre>
<p>This allows you to:</p>
<ul>
<li>Set a <strong>delay</strong> for the message to be consumed ‚Äî for example, you can configure it to be available <strong>3 minutes after being published</strong>.</li>
<li>Attach custom headers through the <code>ApplicationProperties</code> dictionary that travels with the message. These headers can carry metadata useful for all messages, such as tenant information, user identity, or special processing flags (e.g., skipping a message in some scenarios).</li>
</ul>
<p>The others 2 overloads of <code>ProduceCommandAsync</code> allows you to send a message passing only the <code>delay</code> or the <code>applicationProperties</code>, removing the usage of <strong><code>MessageOptions</code></strong> if only one of those properties will be used.</p>
<p>This feature enables flexible message customization without modifying the message payload itself, following best practices for message-driven architectures.</p>
<br>
<h2 id="-internal-implementation">‚öôÔ∏è Internal Implementation</h2>
<p>Both producers rely on a shared low-level component: the IServiceBusProducer<tmessage> interface.</tmessage></p>
<pre><code class="lang-csharp">public interface IServiceBusProducer&lt;in TMessage&gt; where TMessage : class, IServiceBusMessage
{
    Task ProduceAsync(TMessage message, CancellationToken cancellationToken);
}
</code></pre>
<p>The default implementation, <strong><code>ServiceBusProducer&lt;TMessage&gt;</code></strong>, uses the Azure SDK to serialize and send the message:</p>
<pre><code class="lang-csharp">public class ServiceBusProducer&lt;TMessage&gt; : IServiceBusProducer&lt;TMessage&gt; where TMessage : class, IServiceBusMessage
{
    public async Task ProduceAsync(TMessage message, CancellationToken cancellationToken)
    {
        var json = JsonConvert.SerializeObject(message);
        var serviceBusMessage = new ServiceBusMessage(json)
        {
            Subject = message.RoutingKey,
            ApplicationProperties =
            {
                { &quot;MessageType&quot;, message.GetType().FullName },
                { &quot;CreatedAt&quot;, message.CreatedDate.ToString(&quot;O&quot;) }
            }
        };

        await _sender.SendMessageAsync(serviceBusMessage, cancellationToken);
        _logger.LogInformation(&quot;Message {MessageType} published successfully!&quot;, message.GetType().Name);
    }
}
</code></pre>
<br>
<h2 id="-example-of-usage-in-a-controller">üß± Example of Usage in a Controller</h2>
<p>You don‚Äôt need to create a custom producer class ‚Äî AsbFlow already provides the implementations.
Simply inject the appropriate interface (<strong><code>ICommandProducer</code></strong> or <strong><code>IEventProducer</code></strong>) and call the <code>Produce...Async</code> method:</p>
<pre><code class="lang-csharp">[Route(&quot;api/commands&quot;)]
[ApiController]
public class CommandController(ICommandProducer&lt;ExampleCommand1&gt; _producer) : ControllerBase
{
    [HttpPost(&quot;command-example-one&quot;)]
    public async Task&lt;IActionResult&gt; Example1(CancellationToken cancellationToken)
    {
        ExampleCommand1 command = new()
        {
            ExampleMessage = new ExampleMessage
            {
                Cliente = &quot;jose&quot;,
                Id = Guid.NewGuid(),
                Valor = 1111
            }
        };

        await _producer.ProduceCommandAsync(command, cancellationToken);
        return Ok(&quot;Command published successfully!&quot;);
    }
}
</code></pre>
<h3 id="example-with-application-properties">Example with Application Properties</h3>
<p>In this example we`re passing some values in application properties that can be used in MessageHandler.</p>
<pre><code class="lang-csharp">public async Task&lt;IActionResult&gt; Example2WithApplicationProperties(CancellationToken cancellationToken)
{
    ExampleCommand2 command = new()
    {
        ExampleMessage = new ExampleMessage
        {
            Cliente = &quot;jose&quot;,
            Id = Guid.NewGuid(),
            Valor = 1111
        }
    };

    var applicationProperties = new Dictionary&lt;string, object&gt;
    {
        { &quot;CorrelationId&quot;, Guid.NewGuid().ToString() },
        { &quot;Priority&quot;, &quot;High&quot; }
    };

    await _producerTwo.ProduceCommandAsync(command, applicationProperties, cancellationToken);
    return Ok();
}
</code></pre>
<h3 id="example-with-delay">Example with Delay</h3>
<p>In this example we`re passing a delay of 5 minutes, meaning that this message should be processed 5 minutes after sending it.</p>
<pre><code class="lang-csharp">public async Task&lt;IActionResult&gt; Example2WithDelay(CancellationToken cancellationToken)
{
    ExampleCommand2 command = new()
    {
        ExampleMessage = new ExampleMessage
        {
            Cliente = &quot;jose&quot;,
            Id = Guid.NewGuid(),
            Valor = 1111
        }
    };

    var delay = TimeSpan.FromMinutes(5);

    await _producerTwo.ProduceCommandAsync(command, delay, cancellationToken);
    return Ok();
}
</code></pre>
<p>You can combine the <code>aplicationProperties</code> and <code>delay</code> in <strong><code>MessageOptions</code></strong> if you want the message to be sent with this two parameters together.</p>
<br>
<h2 id="-key-points">üß† Key Points</h2>
<ul>
<li>Both <strong>CommandProducer</strong> and <strong>EventProducer</strong> share the same implementation logic.</li>
<li>The difference lies only in <strong>architectural intent</strong> ‚Äî commands indicate actions to be performed, events indicate actions that already happened.</li>
<li>You can use dependency injection to directly obtain any producer type.</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/migueltotti/AzureServiceBusFlow/blob/main/docs/docs/producersComponent.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
